;
;  DZ80 V3.4.1 8080 Disassembly of IMKO-1.bin
;  2012/11/03 21:06
;
	org	0
;
RST0:	lxi	sp,X1470	; 0000  31 70 14	1p.	; Set stack base at memory address 1470
	mvi	a,0aah		; 0003  3e aa		>*	; A := 0xAA
	jmp	init		; 0005  c3 4e 00	CN.
;
RST1:	jmp	printNewPage	; 0008  c3 d4 00	CT.
;
	jmp	readKbdNonZero	; 000b  c3 38 02	C8.
;
	org	10h
;
RST2:	jmp	registersToMem	; 0010  c3 24 0e	C$.
;
	jmp	X00eb		; 0013  c3 eb 00	Ck.
;
	org	18h
;
RST3:	jmp	X1430		; 0018  c3 30 14	C0.
;
	push	b		; 001b  c5		E
	xchg			; 001c  eb		k
	jmp	X00a9		; 001d  c3 a9 00	C).
;
RST4:	jmp	X1433		; 0020  c3 33 14	C3.
;
	jmp	printDString	; 0023  c3 fd 01	C}.
;
	org	28h
;
RST5:	jmp	X1436		; 0028  c3 36 14	C6.
;
	jmp	printNLDString	; 002b  c3 fa 01	Cz.
;
	org	30h
;
RST6:	jmp	X1439		; 0030  c3 39 14	C9.
;
	jmp	printNL		; 0033  c3 19 02	C..
;
	org	38h
;
RST7:	jmp	X143c		; 0038  c3 3c 14	C<.
;
	jmp	X00e8		; 003b  c3 e8 00	Ch.
;
;
; Waits for "Transmission-buffer empty" (TBMT)
; and outputs the contents of A to the UART (IO address 0x02)
;
writeToUART:
	push	psw		; 003e  f5		u	; Backup A
writeToUARTloop:
	in	1		; 003f  db 01		[.	; Read UART status byte
	ani	10h		; 0041  e6 10		f.	; Check for TBMT flag
	jz	writeToUARTloop	; 0043  ca 3f 00	J?.	; Jump back if TBMT flag is not set
	pop	psw		; 0046  f1		q	; Restore A
	out	2		; 0047  d3 02		S.	; Write A to UART
	ret			; 0049  c9		I
;
;
; Send 00h to IO-7, store it at memory address 1470
;
write00hToIO7:
	xra	a		; 004a  af		/	; A := 00h
	jmp	writeIO7	; 004b  c3 f8 03	Cx.
;
;
; Continues the system initialization, started in RST0
; This includes:
; * Setting up JMP instructions in RAM for RST3 ~ RST7
; * Setting up JMP instructions in RAM for ????
; * Determining the amount of installed RAM
; * TODO: More
;
init:	sta	X1401		; 004e  32 01 14	2..	; mem[1401] := 0xAA
	lxi	d,monitor	; 0051  11 74 01	.t.	; Setup jumps to 0x0174 at memory addesses 1430, 1433, 1436, 1439 and 143C
	lxi	h,X1430		; 0054  21 30 14	!0.
	call	fillMem5	; 0057  cd 9b 00	M..
	lxi	d,monitorNLError; 005a  11 5b 01	.[.	; Setup jumps to 0x015B at memory addesses 1473, 1476 and 1479 (147C and 147F are not used?)
	lxi	h,X1473		; 005d  21 73 14	!s.
	call	fillMem5	; 0060  cd 9b 00	M..
	lxi	h,X01bf		; 0063  21 bf 01	!?.	; mem[1476] actually jumps to 0x01BF
	shld	X1477		; 0066  22 77 14	"w.
	lxi	h,X0104		; 0069  21 04 01	!..	; mem[1479] actually jumps to 0x0104
	shld	X147a		; 006c  22 7a 14	"z.
	lxi	h,X02f1		; 006f  21 f1 02	!q.	; mem[1402] := 0x02F1 - something to do with timing TODO: What?
	shld	X1402		; 0072  22 02 14	"..
	mvi	a,80h		; 0075  3e 80		>.	; A := 0x80
	sta	X1472		; 0077  32 72 14	2r.	; mem[1472] := 0x80
	out	3		; 007a  d3 03		S.	; Write 0x80 to the parallel-out (IO-3)
	xra	a		; 007c  af		/	; A := 0x00
	out	6		; 007d  d3 06		S.	; Write 0x00 to IO-6
	out	7		; 007f  d3 07		S.	; Write 0x00 to IO-7 TODO: What are these IOs?
	lxi	h,X14ff		; 0081  21 ff 14	!..	; Set the memory address to 0x14FF, the last of the first 256 bytes of RAM
checkMemLoop:
	mov	b,m		; 0084  46		F	; Backup the contents of the current memory address
	mov	m,a		; 0085  77		w	; Write A (0x00) to memory
	cmp	m		; 0086  be		>	; Read back from memory and compare with A
	jnz	endOfMem	; 0087  c2 8f 00	B..	; If values differ, this is an end-of-memory address
	mov	m,b		; 008a  70		p	; If values are the same, restore memory contents
	inr	h		; 008b  24		$	; Advance to the next memory address
	jmp	checkMemLoop	; 008c  c3 84 00	C..	; Jump back and redo the check
;
endOfMem:
	mov	l,a		; 008f  6f		o	; Set 0x00 to the lower byte of the memory address [H, L] 
	shld	X1481		; 0090  22 81 14	"..	; Store the max memory address at mem[1481]
	rst	1		; 0093  cf		O	; Display a new-page (clear screen)
	lxi	d,X0fb8		; 0094  11 b8 0f	.8.	; Display 'ITKROM V1.2' and report the max memory address
	call	printDHexH	; 0097  cd 51 02	MQ.
	rst	7		; 009a  ff		.	; Jump to the monitor
;
; Fills five sets of consecutive memory addresses with "C3 [E] [D]" triplets,
; which decode to "JMP [DE]" instructions 
;
fillMem5:
	mvi	b,5		; 009b  06 05		..	; B := 5
fillMemLoop:
	mvi	m,0c3h		; 009d  36 c3		6C	; mem[H++] := 0xC3
	inx	h		; 009f  23		#
	mov	m,e		; 00a0  73		s	; mem[H++] := E
	inx	h		; 00a1  23		#
	mov	m,d		; 00a2  72		r	; mem[H++] := D
	inx	h		; 00a3  23		#
	dcr	b		; 00a4  05		.	; --B
	jnz	fillMemLoop	; 00a5  c2 9d 00	B..	; Jump back if B != 0
	ret			; 00a8  c9		I
;
X00a9:	mvi	b,0dh		; 00a9  06 0d		..
	call	inputToM	; 00ab  cd 61 02	Ma.
	xchg			; 00ae  eb		k
	dcx	d		; 00af  1b		.
	pop	b		; 00b0  c1		A
terminateStrD:
	call	X00eb		; 00b1  cd eb 00	Mk.	; Display the value in A, the last char read
	xchg			; 00b4  eb		k	; DE <-> HL
	mvi	m,20h		; 00b5  36 20		6 	; Overwrite the new-line (0Dh) with a space (20h)
	inx	h		; 00b7  23		#	; Move to the next memory byte
	mvi	m,4		; 00b8  36 04		6.	; 4-terminate the string
	ana	a		; 00ba  a7		'	; Reset any flags? TODO
	xchg			; 00bb  eb		k	; DE <-> HL
	ret			; 00bc  c9		I
;
	nop			; 00bd  00		.
	nop			; 00be  00		.
;
; 16-bit compare of [D, E] and [H, L]
;
cmpDH:	mov	a,h		; 00bf  7c		|	; Compare the higher bytes, D and H
	cmp	d		; 00c0  ba		:
	rnz			; 00c1  c0		@	; Return if different
	mov	a,l		; 00c2  7d		}	; Compare the lower bytes, E and L
	cmp	e		; 00c3  bb		;
	ret			; 00c4  c9		I
;
;
; Performs 2047 calls to delay3ms() for a total delay of ~6.1s
;
delay6s:
	push	d		; 00c5  d5		U	; Backup D
	lxi	d,X07ff		; 00c6  11 ff 07	...	; D := 2047
delay6sLoop:
	call	delay3ms	; 00c9  cd 4a 01	MJ.
	dcx	d		; 00cc  1b		.	; --D
	mov	a,d		; 00cd  7a		z	; A := High(D) | Low(D)
	ora	e		; 00ce  b3		3
	jnz	delay6sLoop	; 00cf  c2 c9 00	BI.	; Jump back if D != 0
	pop	d		; 00d2  d1		Q	; Restore D
	ret			; 00d3  c9		I
;
;
; Displays the new-page char, i.e. clears the screen
;
printNewPage:
	push	psw		; 00d4  f5		u	; Backup the value in A
	mvi	a,0ch		; 00d5  3e 0c		>.	; A := 0Ch, the new-page char
	call	X00eb		; 00d7  cd eb 00	Mk.	; Display the value in A
	pop	psw		; 00da  f1		q	; Restore the original value of A
	ret			; 00db  c9		I
;
;
; Executes delay3ms() A times, for a total delay of ~3*A ms
;
delay3Ams:
	call	delay3ms	; 00dc  cd 4a 01	MJ.	; Wait
	dcr	a		; 00df  3d		=	; Decrement A
	jnz	delay3Ams	; 00e0  c2 dc 00	B\.	; Jump back until A becomes zero
	pop	psw		; 00e3  f1		q	; Restore the original value of A
	ret			; 00e4  c9		I
;
X00e5:	call	printNLDString	; 00e5  cd fa 01	Mz.
X00e8:	call	readKbdNonZero	; 00e8  cd 38 02	M8.
X00eb:	push	psw		; 00eb  f5		u
	call	X1476		; 00ec  cd 76 14	Mv.
	cpi	13h		; 00ef  fe 13		~.
	jnz	X1479		; 00f1  c2 79 14	By.
X00f4:	call	readKbdNonZero	; 00f4  cd 38 02	M8.
	cpi	0dh		; 00f7  fe 0d		~.
	cz	printNL		; 00f9  cc 19 02	L..
	cpi	11h		; 00fc  fe 11		~.
	jnz	X00f4		; 00fe  c2 f4 00	Bt.
	jmp	X1479		; 0101  c3 79 14	Cy.
;
X0104:	lda	X1401		; 0104  3a 01 14	:..
	cpi	55h		; 0107  fe 55		~U
	jnz	X0137		; 0109  c2 37 01	B7.
	pop	psw		; 010c  f1		q
	push	psw		; 010d  f5		u
	di			; 010e  f3		s
	push	b		; 010f  c5		E
	cma			; 0110  2f		/
	mov	c,a		; 0111  4f		O
	mvi	b,8		; 0112  06 08		..
	mvi	a,80h		; 0114  3e 80		>.
X0116:	out	6		; 0116  d3 06		S.
	call	delay1402	; 0118  cd b3 01	M3.
	mov	a,c		; 011b  79		y
	rrc			; 011c  0f		.
	mov	c,a		; 011d  4f		O
	dcr	b		; 011e  05		.
	jp	X0116		; 011f  f2 16 01	r..
	mvi	b,2		; 0122  06 02		..
	cpi	75h		; 0124  fe 75		~u
	jnz	X012b		; 0126  c2 2b 01	B+.
	mvi	b,20h		; 0129  06 20		. 
X012b:	xra	a		; 012b  af		/
	out	6		; 012c  d3 06		S.
X012e:	call	delay1402	; 012e  cd b3 01	M3.
	dcr	b		; 0131  05		.
	jp	X012e		; 0132  f2 2e 01	r..
	ei			; 0135  fb		{
	pop	b		; 0136  c1		A
X0137:	pop	psw		; 0137  f1		q
	ani	7fh		; 0138  e6 7f		f.
	out	5		; 013a  d3 05		S.
	ori	80h		; 013c  f6 80		v.
	out	5		; 013e  d3 05		S.
	ani	7fh		; 0140  e6 7f		f.
	out	5		; 0142  d3 05		S.
	cpi	1eh		; 0144  fe 1e		~.
	rp			; 0146  f0		p
	jmp	delayVideoCtrl	; 0147  c3 ae 03	C..
;
;
; Performs 256 iterations of a 2x NOP loop
;
; Duration in cycles:
; CALL + PUSH + MVI + 256 * (DCR + NOP + NOP + JNZ) + POP + RET =
; = 17 + 11 + 7 + 256 * (5 + 4 + 4 + 10) + 10 + 10 = 5943
; At 2MHz clock speed, this takes ~3ms at the caller
;
delay3ms:
	push	d		; 014a  d5		U	; Backup D
	mvi	d,0		; 014b  16 00		..	; D := 0
delay3msNopLoop:
	dcr	d		; 014d  15		.	; --D
	nop			; 014e  00		.	; 2x NO-OP
	nop			; 014f  00		.
	jnz	delay3msNopLoop	; 0150  c2 4d 01	BM.	; Jump back if D != 0
	pop	d		; 0153  d1		Q	; Restore D
	ret			; 0154  c9		I
;
;
; Converts the '0'~'9', 'A'~'F' character at memory address D to a 00h~0Fh value.
; The result is stored in A. The CARRY flag is set in case of an error.
;
memHexCharToValue:
	ldax	d		; 0155  1a		.	; A := mem[D]
	jmp	hexCharToValue	; 0156  c3 51 0e	CQ.
;
;
; Display a new-line, then ' ERROR', then fall-through to the Monitor routine
;
	org	15bh
;
monitorNLError:
	call	printNL		; 015b  cd 19 02	M..	; Print a new-line
monitorError:
	lxi	d,X0ed6		; 015e  11 d6 0e	.V.	; Set D to the address of ' ERROR'
monitorDMsg:
	call	printDString	; 0161  cd fd 01	M}.	; Display the message pointed by D
monitorNoMsg:
	mvi	a,40h		; 0164  3e 40		>@	; A := 40h
	out	7		; 0166  d3 07		S.	; Output 40h to IO-7
	mvi	b,26h		; 0168  06 26		.&	; B := 38 (26h)
delay3B:
	call	delay3ms	; 016a  cd 4a 01	MJ.	; Call delay3ms() B times in a loop. Total delay ~114ms
	dcr	b		; 016d  05		.
	jnz	delay3B		; 016e  c2 6a 01	Bj.
	xra	a		; 0171  af		/	; A := 00h
	out	7		; 0172  d3 07		S.	; Output 00h to IO-7
;
; Entry point for the IMKO-1 system monitor. 
; It allows for the execution of 26 predefined functions, by typing 'A' ~ 'Z'
;
monitor:
	lxi	sp,X1470	; 0174  31 70 14	1p.	; Reset stack base at memory address 1470
	lxi	d,X0edd		; 0177  11 dd 0e	.].	; Display the function selection prompt (TODO)
	call	printNLDString	; 017a  cd fa 01	Mz.
	jmp	monitor2	; 017d  c3 92 01	C..
;
	org	182h
;
X0182:	cmc			; 0182  3f		?
	lxi	b,X8032		; 0183  01 32 80	.2.
	inr	d		; 0186  14		.
	jmp	endUART		; 0187  c3 3a 03	C:.
;
	cpi	0dh		; 018a  fe 0d		~.
	jz	printNL		; 018c  ca 19 02	J..
	jmp	X00eb		; 018f  c3 eb 00	Ck.
;
;
; Part II of the monitor
; 
monitor2:
	call	printNL		; 0192  cd 19 02	M..	; TODO: PrintCRLF?
	call	X00e8		; 0195  cd e8 00	Mh.	; TODO: Read a char in A?
;
; Executes one of 26 routines, indexed by the letter in A: 'A' ~ 'Z'
;
tableJmpA:
	lxi	d,X0f7e		; 0198  11 7e 0f	.~.	; Base address of the jump table
	sui	41h		; 019b  d6 41		VA	; 'A' (41h) -> 00h
	jc	monitorNLError	; 019d  da 5b 01	Z[.	; Negative value after the subtraction is an error
	cpi	1bh		; 01a0  fe 1b		~.	; Compare A with 27 (1Bh)
	jnc	monitorNLError	; 01a2  d2 5b 01	R[.	; Greater-than-or-equal is an error
	mov	l,a		; 01a5  6f		o	; (H, L) := (0, A)
	mvi	h,0		; 01a6  26 00		&.
	dad	h		; 01a8  29		)	; (H, L) := (0, 2*A) - the table offset in bytes
	dad	d		; 01a9  19		.	; Add the table base address. Now (H, L) points to the target routine's address
	mov	e,m		; 01aa  5e		^	; Load the target address into (D, E)
	inx	h		; 01ab  23		#
	mov	d,m		; 01ac  56		V
	xchg			; 01ad  eb		k	; Swap HL <-> DE. Now the target address is in HL
	lxi	d,monitor	; 01ae  11 74 01	.t.	; Push a default return address on the stack
	push	d		; 01b1  d5		U
	pchl			; 01b2  e9		i	; PC := HL. Transfer the execution to the target routine
;
;
; Performs mem[1402] iterations of an empty loop
; With the default value of 753 (02F1h) in memory, the delay is ~9ms
;
delay1402:
	push	h		; 01b3  e5		e	; Backup [H, L]
	lhld	X1402		; 01b4  2a 02 14	*..	; [H, L] := mem[1402]
delay1402loop:
	dcx	h		; 01b7  2b		+	; Decrement [H, L]
	mov	a,l		; 01b8  7d		}	; A := H | L
	ora	h		; 01b9  b4		4
	jnz	delay1402loop	; 01ba  c2 b7 01	B7.	; Jump back if [H, L] != 0x0000
	pop	h		; 01bd  e1		a	; Restore [H, L]
	ret			; 01be  c9		I
;
X01bf:	push	b		; 01bf  c5		E
	push	h		; 01c0  e5		e
	call	X01d6		; 01c1  cd d6 01	MV.
	mov	b,a		; 01c4  47		G
	lda	X1472		; 01c5  3a 72 14	:r.
	ana	a		; 01c8  a7		'
	mov	a,b		; 01c9  78		x
	cm	toggleLetterCase; 01ca  fc e2 01	|b.
	cpi	3		; 01cd  fe 03		~.
	jz	monitor		; 01cf  ca 74 01	Jt.
	ana	a		; 01d2  a7		'
	pop	h		; 01d3  e1		a
	pop	b		; 01d4  c1		A
	ret			; 01d5  c9		I
;
X01d6:	lxi	h,X1400		; 01d6  21 00 14	!..
	in	0		; 01d9  db 00		[.
	mov	b,a		; 01db  47		G
	xra	m		; 01dc  ae		.
	cm	X0e84		; 01dd  fc 84 0e	|..
	xra	a		; 01e0  af		/
	ret			; 01e1  c9		I
;
;
; Switches the case of the Latin letter character stored in A
; A <-> a ... Z <-> z, all other characters remain unchanged
;
toggleLetterCase:
	cpi	41h		; 01e2  fe 41		~A	; If ASCII code is less-than 0x41 ('A'), return unchanged
	rc			; 01e4  d8		X
	cpi	5bh		; 01e5  fe 5b		~[	; If code is less-than 0x5B ('['), i.e. an uppercase letter, convert to lowercase and return
	jc	toLowerCase	; 01e7  da f3 01	Zs.
	cpi	61h		; 01ea  fe 61		~a	; If ASCII code is less-than 0x61 ('a'), return unchanged
	rc			; 01ec  d8		X
	cpi	7bh		; 01ed  fe 7b		~{	; If ASCII code is >= 0x7B ('{'), return unchanged
	rnc			; 01ef  d0		P
	sui	20h		; 01f0  d6 20		V 	; It's a lowercase letter. Convert to uppercase by subtracting 0x20
	ret			; 01f2  c9		I
;
toLowerCase:
	adi	20h		; 01f3  c6 20		F 	; Convert to lowercase by adding 0x20
	ret			; 01f5  c9		I
;
;
; Prompts for an address and displays the string located at it
;
printMemString:
	call	promptStartReadH; 01f6  cd 08 02	M..	; Load the user-specified address in H
	xchg			; 01f9  eb		k	; D := H, store a copy of the address in D
;
; Prints a CR/LF on the monitor, followed by the string at the address in D
;
printNLDString:
	call	printNL		; 01fa  cd 19 02	M..	; Print the new-line
printDString:
	ldax	d		; 01fd  1a		.	; Load the current character in A
	inx	d		; 01fe  13		.	; Advance D to the next memory address
	cpi	4		; 01ff  fe 04		~.	; Check A for end-of-string terminator char
	rz			; 0201  c8		H	; Return if done
	call	X00eb		; 0202  cd eb 00	Mk.	; TODO
	jmp	printDString	; 0205  c3 fd 01	C}.	; Loop until the whole string has been processed
;
;
; TODO. Displays a 'START:' prompt, reads a line of input and converts it to an address, stored in H
;
promptStartReadH:
	lxi	d,X0ecf		; 0208  11 cf 0e	.O.	; Set the (address of the) prompt string in D: 'START:'
promptDReadH:
	call	printNLDString	; 020b  cd fa 01	Mz.	; Display the string, starting at the memory address in D
readAddrInH:
	call	readLineTo1410	; 020e  cd 7b 02	M{.	; Read a line from the keyboard
	call	string1410ToAddr; 0211  cd 98 03	M..	; Convert to an address
;
; Displays a CR/LF pair, i.e. moves to a new line
;
;
	org	219h
;
printNL:
	push	psw		; 0219  f5		u	; Backup A and D
	push	d		; 021a  d5		U
	lxi	d,X0ff9		; 021b  11 f9 0f	.y.	; Point D to the address of the CR/LF string
	call	printDString	; 021e  cd fd 01	M}.	; Display the string
	pop	d		; 0221  d1		Q	; Restore A and D
	pop	psw		; 0222  f1		q
	ret			; 0223  c9		I
;
;
; Prompts for input of a start and end addesses and stores them on the stack
; (&start is pushed first, &end is pushed second)
;
promptStartEnd:
	call	promptStartReadH; 0224  cd 08 02	M..	; HL := &start, SP := &return
	xthl			; 0227  e3		c	; HL := &return, SP := &start
	push	h		; 0228  e5		e	; HL := &return, SP := &return, &start
	lxi	d,X0fc5		; 0229  11 c5 0f	.E.	; Set the prompt string to 'END:'
	call	promptDReadH	; 022c  cd 0b 02	M..	; HL := &end, SP := &return, &start
	xthl			; 022f  e3		c	; HL := &return, SP := &end, &start
	pchl			; 0230  e9		i	; PC := HL, return to the caller address
;
;
; Compares D and H and "returns" to the monitor if they are equal
;
toMonitorIfDeqH:
	call	cmpDH		; 0231  cd bf 00	M?.	; Compare
	rnz			; 0234  c0		@	; Regular return, if not equal
	jmp	monitorNoMsg	; 0235  c3 64 01	Cd.	; Jump to the monitor, if equal
;
;
; TODO. Reads from the keyboard a single non-zero byte into A
;
readKbdNonZero:
	call	X1476		; 0238  cd 76 14	Mv.
	jz	readKbdNonZero	; 023b  ca 38 02	J8.	; Loop back until a non-zero value is entered
	ret			; 023e  c9		I
;
;
; Displays the current memory address (H, L),
; followed by the value of the byte at this address
;
printMemAddrValue:
	call	printNLHexWord	; 023f  cd c4 03	MD.	; Print (H, L) in hex
printMemHexByte:
	mov	a,m		; 0242  7e		~	; Load the current memory byte into A
	jmp	printHexByteSpace; 0243  c3 59 02	CY.	; Display A in hex
;
;
; Inputs a 4-terminated string into a specified memory location
;
writeStrToMem:
	call	promptStartReadH; 0246  cd 08 02	M..	; Prompt for and input the target memory address in H
	mvi	b,4		; 0249  06 04		..	; Set 04h as a terminator char
	call	inputToM	; 024b  cd 61 02	Ma.	; Input the string in memory
	lxi	d,X0fc5		; 024e  11 c5 0f	.E.	; Display 'END:' and report the string's end address
printDHexH:
	call	printNLDString	; 0251  cd fa 01	Mz.	; Print the string pointed by D, followed by the value of HL
printHexHL:
	mov	a,h		; 0254  7c		|	; First print the upper byte, H
	call	printHexByte	; 0255  cd ab 02	M+.
	mov	a,l		; 0258  7d		}	; then the lower byte, L (followed by a space)
printHexByteSpace:
	call	printHexByte	; 0259  cd ab 02	M+.	; Display A as hex
	mvi	a,20h		; 025c  3e 20		> 	; Append a space
	jmp	X00eb		; 025e  c3 eb 00	Ck.
;
;
; Read from keyboard and store the input in memory, until the char in B is entered
;
inputToM:
	call	readKbdNonZero	; 0261  cd 38 02	M8.	; Read a char in A
	mov	m,a		; 0264  77		w	; Store the char in memory
	inx	h		; 0265  23		#	; Advance to the next memory byte
	cmp	b		; 0266  b8		8	; Check for end-of-string
	rz			; 0267  c8		H	; Return if found
	call	X00eb		; 0268  cd eb 00	Mk.	; Display the char
	cpi	8		; 026b  fe 08		~.	; Check for backspace (08h)
	jnz	inputToM	; 026d  c2 61 02	Ba.
	dcx	h		; 0270  2b		+	; Handle backspace - reduce the memory address by two
	dcx	h		; 0271  2b		+
	jmp	inputToM	; 0272  c3 61 02	Ca.
;
;
; Displays a 'BYTE:' prompt and reads a line of input to memory address 1410h
;
promptByte:
	lxi	d,X0fb2		; 0275  11 b2 0f	.2.	; Set D to the prompt string of 'BYTE:'
	call	printDString	; 0278  cd fd 01	M}.
;
; Prompts for keyboard input and stores it at memory address 1410h
;
readLineTo1410:
	mvi	a,20h		; 027b  3e 20		> 	; Prompt char? TODO
	lxi	d,X1410		; 027d  11 10 14	...	; D := 1410h
showPrompt:
	call	X00eb		; 0280  cd eb 00	Mk.	; Display the prompt char in A
	cpi	5eh		; 0283  fe 5e		~^	; Return if... TODO
	rz			; 0285  c8		H
readCharToD:
	call	readKbdNonZero	; 0286  cd 38 02	M8.	; Input a single char from the keyboard, into A
handleLastKbdChar:
	cpi	8		; 0289  fe 08		~.	; Check for and handle backspace (08h)
	jz	backspaceRead	; 028b  ca 9f 02	J..
	stax	d		; 028e  12		.	; Store the char into mem[D]
	cpi	0dh		; 028f  fe 0d		~.	; Check for a new-line (0Dh)
	jz	terminateStrD	; 0291  ca b1 00	J1.	; Terminat the string and return
	mov	a,e		; 0294  7b		{	; Prevent buffer overrun (1410h~142Fh), by checking the lower byte of DE
	cpi	2eh		; 0295  fe 2e		~.	; The last non-termination symbol can be stored at 142Eh (E == 2Eh)
	jz	readCharToD	; 0297  ca 86 02	J..	; Keep overwriting the char at 142Eh with new input
	ldax	d		; 029a  1a		.	; Restore the value in A to be the last char read
	inx	d		; 029b  13		.	; Advance to the next byte in the memory buffer
	jmp	showPrompt	; 029c  c3 80 02	C..
;
backspaceRead:
	mov	a,e		; 029f  7b		{	; Prevent buffer underrun (1410h~142Fh), by checking the lower byte of DE
	cpi	10h		; 02a0  fe 10		~.	; The first symbol is always at 1410h (E == 10h)
	jz	readCharToD	; 02a2  ca 86 02	J..	; Overwrite the char at 1410h with new input
	dcx	d		; 02a5  1b		.	; Not at 1410h yet, so execute the backspace - take a step back
	mvi	a,8		; 02a6  3e 08		>.	; A := 08h (backspace)
	jmp	showPrompt	; 02a8  c3 80 02	C..
;
;
; Displays the value in A as a pair of '0' ~ 'F' ASCII chars
; 
printHexByte:
	push	psw		; 02ab  f5		u	; Backup A
	rrc			; 02ac  0f		.	; Shift right four times, the upper nibble takes the place of the lower nibble
	rrc			; 02ad  0f		.	; and will be displayed first
	rrc			; 02ae  0f		.
	rrc			; 02af  0f		.
	call	printHexNibble	; 02b0  cd b4 02	M4.
	pop	psw		; 02b3  f1		q	; Restore A, display the lower nibble
;
; Prints the lower nibble of A as a '0' ~ 'F' ASCII char
;
printHexNibble:
	ani	0fh		; 02b4  e6 0f		f.	; Set zeros for the upper nibble of A
	adi	30h		; 02b6  c6 30		F0	; 00h -> '0' (30h)
	cpi	3ah		; 02b8  fe 3a		~:	; Compare with ':' (3Ah)
	jc	X00eb		; 02ba  da eb 00	Zk.	; If A is smaller, i.e. '0'~'9', display it and return
	adi	7		; 02bd  c6 07		F.	; Shift A to the 'A'~'F' range
	jmp	X00eb		; 02bf  c3 eb 00	Ck.	; Display & return
;
;
; Prompts for 'Tape Header', reads a string to 1410h  and writes it to UART
;
writeUARTHeader:
	call	promptTapeHeader; 02c2  cd 6c 0e	Ml.	; Read input to 1410h
	call	delay6s		; 02c5  cd c5 00	ME.	; Wait for a while
	mvi	b,40h		; 02c8  06 40		.@	; B := 64
	mvi	a,0dh		; 02ca  3e 0d		>.	; Write 64 CR (0x0D) characters to UART
writeCRLoop:
	call	writeToUART	; 02cc  cd 3e 00	M>.
	dcr	b		; 02cf  05		.
	jnz	writeCRLoop	; 02d0  c2 cc 02	BL.	; Jump back if more CR's need to be written
	lxi	d,X1410		; 02d3  11 10 14	...	; Set D to 1410
write1410StrLoop:
	ldax	d		; 02d6  1a		.	; Load the byte at mem[D]
	call	writeToUART	; 02d7  cd 3e 00	M>.	; Send it to the UART
	inx	d		; 02da  13		.	; ++D
	cpi	4		; 02db  fe 04		~.	; Was this the string terminator byte (0x04)?
	jnz	write1410StrLoop; 02dd  c2 d6 02	BV.	; Jump back if not end-of-string
	ret			; 02e0  c9		I
;
;
; Inputs a target tape-header string and locates the program body with this header
;
findProgInUART:
	call	promptTapeHeader; 02e1  cd 6c 0e	Ml.	; Prompt for a header string, store it at 1410h
	lxi	d,X0f02		; 02e4  11 02 0f	...	; Display 'FILES FOUND:'. All skipped headers will be listed
	call	printNLDString	; 02e7  cd fa 01	Mz.
findNextHeader:
	call	printNL		; 02ea  cd 19 02	M..
	lxi	h,X1410		; 02ed  21 10 14	!..	; Set the current memory address to 1410h
findLeading0Ds:
	mvi	b,20h		; 02f0  06 20		. 	; 64 ODh chars are written before each header. Find at least 32 (20h)
skipLeading0D:
	call	readFromUART	; 02f2  cd 62 0e	Mb.	; Read a char from UART
	cpi	0dh		; 02f5  fe 0d		~.	; Check for 0Dh
	jnz	findLeading0Ds	; 02f7  c2 f0 02	Bp.	; If not a 0Dh, restart the search
	dcr	b		; 02fa  05		.	; It's a 0Dh, decrement the target count
	jnz	skipLeading0D	; 02fb  c2 f2 02	Br.	; Jump back if any more 0Ds need to be found
skip0Ds:
	call	readFromUART	; 02fe  cd 62 0e	Mb.	; Skip any remaining 0Ds
	cpi	0dh		; 0301  fe 0d		~.
	jz	skip0Ds		; 0303  ca fe 02	J~.
	call	X00eb		; 0306  cd eb 00	Mk.	; The next char of the UART header is in A. Display it
	cmp	m		; 0309  be		>	; Compare it with the target char at mem[H]
	jnz	headerMismatch	; 030a  c2 14 03	B..	; Jump if different
	inx	h		; 030d  23		#	; Advance to the next memory byte
	cpi	4		; 030e  fe 04		~.	; Check A for an end-of-string
	jnz	skip0Ds		; 0310  c2 fe 02	B~.	; Jump back if more chars from the tape-header need to match
	ret			; 0313  c9		I
;
headerMismatch:
	cpi	4		; 0314  fe 04		~.	; Check A for an end-of-string
	jz	findNextHeader	; 0316  ca ea 02	Jj.	; If the UART header is over (and is not the one requested), skip the whole program body
	call	readFromUART	; 0319  cd 62 0e	Mb.	; Read and display any remaining chars from the UART header
	call	X00eb		; 031c  cd eb 00	Mk.
	jmp	headerMismatch	; 031f  c3 14 03	C..	; Jump back unitl the current UART header ends
;
;
; Inputs a tape header string, writes it to UART, followed by 
; the contents of the program located at memory address 1600
;
writeProgToUART:
	call	writeUARTHeader	; 0322  cd c2 02	MB.	; Prompt for a header string, write it to UART
	lxi	h,X1600		; 0325  21 00 16	!..	; Set the memory address to 1600
	mov	e,m		; 0328  5e		^	; (D, E) := (mem[1601], mem[1600]) - the address after the last byte of the program
	inx	h		; 0329  23		#
	mov	d,m		; 032a  56		V
	dcx	h		; 032b  2b		+	; H is back at 1600. The end-of-program address is stored together with the program itself
writeProgLoop:
	mov	a,m		; 032c  7e		~	; Load the current memory byte into A
	call	writeToUART	; 032d  cd 3e 00	M>.	; Send it to UART
	inx	h		; 0330  23		#	; Advance to the next memory address
	call	cmpDH		; 0331  cd bf 00	M?.	; Compare the current memory address with the end-of-program address (in DE)
	jnz	writeProgLoop	; 0334  c2 2c 03	B,.	; Jump back if DE has not been reached
	call	delay6s		; 0337  cd c5 00	ME.	; Wait for a while
endUART:
	call	write00hToIO7	; 033a  cd 4a 00	MJ.
monitorEnd:
	lxi	d,X0e47		; 033d  11 47 0e	.G.	; Set D to the address of the '\nEND' string
	jmp	monitorDMsg	; 0340  c3 61 01	Ca.	; Display the string in D, then fall-through to the Monitor
;
;
; Prompts for a tape-header name and loads the program with this name from UART to 1600h in memory
;
readProgFrmUART:
	call	findProgInUART	; 0343  cd e1 02	Ma.	; Locate the program start
	lxi	h,X1600		; 0346  21 00 16	!..	; Set the current memory address to 1600h
	mvi	c,3fh		; 0349  0e 3f		.?	; Set '?' (3Fh) as the default value for the readUARTSafe() calls
	call	readUARTSafe	; 034b  cd 65 03	Me.	; Read the first UART byte, store it in E and at mem[1600h]
	mov	e,a		; 034e  5f		_
	mov	m,a		; 034f  77		w
	inx	h		; 0350  23		#	; H := 1601h
	call	readUARTSafe	; 0351  cd 65 03	Me.	; Read the second UART byte, store it in D and at mem[1601h]
	mov	d,a		; 0354  57		W	; This way, the program's end address is in both DE and mem[1601h, 1600h]
	mov	m,a		; 0355  77		w
	inx	h		; 0356  23		#	; H := 1602h
readProgByte:
	call	readUARTSafe	; 0357  cd 65 03	Me.	; Read a byte from UART
	mov	m,a		; 035a  77		w	; Store it at the current memory location
	inx	h		; 035b  23		#	; Advance to the next memory byte
	call	cmpDH		; 035c  cd bf 00	M?.	; Check if the end-address D has been reached
	jnz	readProgByte	; 035f  c2 57 03	BW.	; Jump back if not
	jmp	X0182		; 0362  c3 82 01	C..	; TODO
;
;
; Reads a single char from the UART into A. 
; In case of an error, returns the default value from C
;
readUARTSafe:
	call	readFromUART	; 0365  cd 62 0e	Mb.	; Perform a plain read into A
	mov	b,a		; 0368  47		G	; Backup A
	in	1		; 0369  db 01		[.	; Read the UART status
	ani	0eh		; 036b  e6 0e		f.	; AND with a mask for all the error bits
	mov	a,b		; 036d  78		x	; Restore A
	rz			; 036e  c8		H	; Return if no error bits were set
	mov	a,c		; 036f  79		y	; Use the default, C, in case of an error
	ana	a		; 0370  a7		'	; Check for zero
	cnz	printNL		; 0371  c4 19 02	D..	; Display C, if non-zero
	cnz	X00eb		; 0374  c4 eb 00	Dk.	; TODO
	mvi	c,0		; 0377  0e 00		..	; Set the default to be zero, for any further reads
	ret			; 0379  c9		I
;
X037a:	db	'READ'					; 037a
	db	4					; 037e .
;
; Fills a block of memory with a given byte value
;
;
memSet:	call	promptStartEnd	; 037f  cd 24 02	M$.	; Read &start and &end, place them on the stack
	call	promptByte	; 0382  cd 75 02	Mu.	; Read and convert the fill-value in A
	call	string1410ToByte; 0385  cd 98 0e	M..
	pop	d		; 0388  d1		Q	; D := &end
	pop	h		; 0389  e1		a	; H := &start
	mov	b,a		; 038a  47		G	; B := fill-value
memSetLoop:
	mov	m,b		; 038b  70		p	; Overwrite the current memory byte with the fill-value
	call	toMonitorIfDeqH	; 038c  cd 31 02	M1.	; TODO: Fall-through to the monitor, if D == H
	inx	h		; 038f  23		#	; ++H
	jmp	memSetLoop	; 0390  c3 8b 03	C..	; Jump back, until the whole memory block is overwritten
;
;
; Converts the sequence of hex characters at memory address 1410
; to a 16-bit address, stored in (H, L). '0FFF' -> 0FFFh
; The lower byte (L) is also stored in A
;
	org	398h
;
string1410ToAddr:
	lxi	d,X1410		; 0398  11 10 14	...	; D := 1410h
stringDToAddr:
	xra	a		; 039b  af		/	; A := 0, (H, L) := (0, 0), B := 0
	mov	h,a		; 039c  67		g
	mov	l,a		; 039d  6f		o
	mov	b,a		; 039e  47		G
accumulateMemHex:
	call	memHexCharToValue; 039f  cd 55 01	MU.	; Store the next hex digit in A
	mov	c,a		; 03a2  4f		O	; Also copy it to C
	mov	a,l		; 03a3  7d		}	; Store the last valid byte in A, in case of a return
	rc			; 03a4  d8		X	; Return in case of a conversion error or end-of-string
	dad	h		; 03a5  29		)	; 'Append' the next hex digit to (H, L)
	dad	h		; 03a6  29		)	; (H, L) := 16 * (H, L) + (0, C)
	dad	h		; 03a7  29		)
	dad	h		; 03a8  29		)
	dad	b		; 03a9  09		.
	inx	d		; 03aa  13		.	; Advance to the next memory address
	jmp	accumulateMemHex; 03ab  c3 9f 03	C..	; Loop until the char->hex conversion fails
;
;
; Executes a delay for the correct processing of the video-control code in A
; See the SFF96364 datasheet for timing details
;
delayVideoCtrl:
	push	psw		; 03ae  f5		u	; Backup the original value of A. Restored in delay3Ams()
	ani	0fh		; 03af  e6 0f		f.	; Clear the first nibble of A
	cpi	0ch		; 03b1  fe 0c		~.	; Check for 0Ch - 'new page' / 'clear screen'
	mvi	a,2ch		; 03b3  3e 2c		>,	; Delay for 44 * 3ms = 132ms, if the control code is 0Ch
	jz	delay3Ams	; 03b5  ca dc 00	J\.
	mvi	a,3		; 03b8  3e 03		>.	; Delay for 3 * 3ms = 9ms, for any other control code
	jmp	delay3Ams	; 03ba  c3 dc 00	C\.
;
;
; Prints a new line, then the value of (H, L) as a four-char '0'~'F' string
;
	org	3c4h
;
printNLHexWord:
	call	printNL		; 03c4  cd 19 02	M..
	jmp	printHexHL	; 03c7  c3 54 02	CT.	; Also returns
;
;
; Prints a memory dump, starting from a given address, listing each byte on a separate line
;
memList:
	call	promptStartReadH; 03ca  cd 08 02	M..	; Read the start address in H
memListPage:
	mvi	b,0fh		; 03cd  06 0f		..	; Display 15 lines per page
memListLine:
	call	printMemAddrValue; 03cf  cd 3f 02	M?.	; Print the current memory address H and its contents
	inx	h		; 03d2  23		#	; Advance to the next byte
	dcr	b		; 03d3  05		.
	jnz	memListLine	; 03d4  c2 cf 03	BO.	; Loop back if there are more lines to print in this page
	lxi	d,X0e40		; 03d7  11 40 0e	.@.	; Prompt for input: 'MORE?'
	call	X00e5		; 03da  cd e5 00	Me.
	cpi	59h		; 03dd  fe 59		~Y	; Check for a 'Y'
	jz	memListPage	; 03df  ca cd 03	JM.	; Print another page, if 'Y'
	pop	h		; 03e2  e1		a	; TODO. Pop the 0174h from the stack? It'll be pushed again later?
	jmp	tableJmpA	; 03e3  c3 98 01	C..	; Use the entered value for the monitor jump-table 
;
;
; Infinite loop of reading a char from UART and then displaying it
;
readLoopUART:
	call	readFromUART	; 03e6  cd 62 0e	Mb.
	call	X00eb		; 03e9  cd eb 00	Mk.
	jmp	readLoopUART	; 03ec  c3 e6 03	Cf.
;
;
; Toggles the output to IO-7 between 00h and 80h. 
; The new value is also stored at memory address 1470
;
toggleIO7:
	lda	X1470		; 03ef  3a 70 14	:p.
	ana	a		; 03f2  a7		'
	jnz	write00hToIO7	; 03f3  c2 4a 00	BJ.
write80hToIO7:
	mvi	a,80h		; 03f6  3e 80		>.	; A := 80h
writeIO7:
	out	7		; 03f8  d3 07		S.	; Send A to IO-7, store it at memory address 1470
	sta	X1470		; 03fa  32 70 14	2p.
	ret			; 03fd  c9		I
;
	org	400h
;
X0400:	nop			; 0400  00		.
;
	org	7ffh
;
X07ff:	nop			; 07ff  00		.
;
; BASIC literals? TODO...
;
;
	org	0c00h
;
	db	4ch,45h,54h,87h,4fh,49h,46h,86h		; 0c00 LET.OIF.
	db	0d2h,47h,4fh,54h,4fh,85h,2ch,47h	; 0c08 RGOTO.,G
	db	4fh,53h,55h,42h,85h,0c7h,52h,45h	; 0c10 OSUB.GRE
	db	54h,55h,52h,4eh,85h,0e9h,52h,45h	; 0c18 TURN.iRE
	db	4dh,86h,0cch,46h,4fh,52h,86h,4		; 0c20 M.LFOR..
	db	49h,4eh,50h,55h,54h,86h,0edh,50h	; 0c28 INPUT.mP
	db	52h,49h,4eh,54h,85h,6dh,53h,54h		; 0c30 RINT.mST
	db	4fh,50h,85h,7,56h,44h,55h,8bh		; 0c38 OP..VDU.
	db	57h,43h,41h,4ch,4ch,8bh,76h,50h		; 0c40 WCALL.vP
	db	45h,45h,4bh,8bh,7eh,50h,4fh,4bh		; 0c48 EEK.~POK
	db	45h,8bh,92h,47h,45h,54h,8bh,0a0h	; 0c50 E..GET. 
	db	50h,55h,54h,8bh,0b8h,53h,50h,52h	; 0c58 PUT.8SPR
	db	41h,94h,7ch,87h,49h,52h,4eh,44h		; 0c60 A.|.IRND
	db	88h,6dh,41h,42h,53h,88h,9ah,53h		; 0c68 .mABS..S
	db	49h,5ah,45h,88h,0a3h,53h,50h,52h	; 0c70 IZE.#SPR
	db	42h,94h,7ch,88h,4bh,54h,4fh,86h		; 0c78 B.|.KTO.
	db	14h,89h,32h,53h,54h,45h,50h,86h		; 0c80 ..2STEP.
	db	20h,86h,26h,3eh,3dh,87h,67h,23h		; 0c88  .&>=.g#
	db	87h,6dh,3eh,87h,73h,3dh,87h,82h		; 0c90 .m>.s=..
	db	3ch,3dh,87h,7ah,3ch,87h,88h,87h		; 0c98 <=.z<...
	db	8eh,0					; 0ca0 ..
;
; Displays and allows for modification of the memory contents, starting at a given address 
;
memEdit:
	call	promptStartReadH; 0ca2  cd 08 02	M..	; Input the target starting address
	dcx	h		; 0ca5  2b		+
memEditNext:
	inx	h		; 0ca6  23		#	; Advance to the next byte in memory
memEditCurrent:
	call	printMemAddrValue; 0ca7  cd 3f 02	M?.	; Display the current address and its contents
	lxi	d,X1410		; 0caa  11 10 14	...	; D := 1410h, the start of the keyboard buffer
	call	readKbdNonZero	; 0cad  cd 38 02	M8.	; Read a single char from the keyboard into A
	cpi	0dh		; 0cb0  fe 0d		~.	; Check for a new-line (0Dh)
	jz	memEditNext	; 0cb2  ca a6 0c	J&.	; If equal, move to the next byte
	cpi	5eh		; 0cb5  fe 5e		~^	; Check for '^' (5Eh)
	jz	memEditPrev	; 0cb7  ca c6 0c	JF.	; If equal, move to the previous byte
	call	handleLastKbdChar; 0cba  cd 89 02	M..	; Store A at 1410h and read the rest of the input string
	push	psw		; 0cbd  f5		u	; Backup F
	call	string1410ToByte; 0cbe  cd 98 0e	M..	; Convert the input string to a byte
	mov	m,a		; 0cc1  77		w	; Overwrite the current memory location with it
	pop	psw		; 0cc2  f1		q	; Restore the original F
	jnz	memEditNext	; 0cc3  c2 a6 0c	B&.	; Move to the next byte
memEditPrev:
	dcx	h		; 0cc6  2b		+	; Move to the previous memory address
	jmp	memEditCurrent	; 0cc7  c3 a7 0c	C'.
;
;
; Modifies the registers' in-memory storage values, 1404h ~ 140Fh
; This subroutine does not alter the registers' own values! This is done in memToRegisters().
;
setMemRegisters:
	call	X00e8		; 0cca  cd e8 00	Mh.	; Input a letter into A TODO: No prompt?
	call	printNL		; 0ccd  cd 19 02	M..
	cpi	20h		; 0cd0  fe 20		~ 	; Compare A with ' ' (20h)
	jz	printRegisters	; 0cd2  ca 40 0d	J@.	; If equal, display current memory values and return
	cpi	46h		; 0cd5  fe 46		~F	; Compare A with 'F' (46h)
	jz	setFlags	; 0cd7  ca 19 0d	J..	; If equal, modify the F memory byte and return
	lxi	h,X0ec8		; 0cda  21 c8 0e	!H.	; Position H to the start of the 'HLDEBCA' sequence
	lxi	b,X0007		; 0cdd  01 07 00	...	; B := 0, C := 7 - the number of register names to check
checkRegName:
	cmp	m		; 0ce0  be		>	; Compare A with the current memory byte / register name
	jz	setRegisterByte	; 0ce1  ca 0a 0d	J..	; If equal, modify a single register memory byte (A ~ H) and return
	inx	h		; 0ce4  23		#	; Advance H to the next register name char
	dcr	c		; 0ce5  0d		.	; Decrement the C counter
	jnz	checkRegName	; 0ce6  c2 e0 0c	B`.
	lxi	h,X140c		; 0ce9  21 0c 14	!..	; Set H to the base of the SP memory word
	cpi	53h		; 0cec  fe 53		~S	; Compare A with 'S' (53h)
	jz	setRegisterWord	; 0cee  ca f8 0c	Jx.	; If equal, modify the SP memory word (currently pointed by H)
	cpi	50h		; 0cf1  fe 50		~P	; Compare A with 'P' (50h)
	jnz	monitorNLError	; 0cf3  c2 5b 01	B[.	; If not equal, it's an error
	inx	h		; 0cf6  23		#	; Advance H to the memory word for the PC register
	inx	h		; 0cf7  23		#
setRegisterWord:
	mov	e,m		; 0cf8  5e		^	; Store the current memory word in DE
	inx	h		; 0cf9  23		#
	mov	d,m		; 0cfa  56		V
	dcx	h		; 0cfb  2b		+
	xchg			; 0cfc  eb		k	; DE <-> HL, the current value is now in HL, current mem address is in DE
	push	d		; 0cfd  d5		U	; Backup the current memory address DE
	call	printNLHexWord	; 0cfe  cd c4 03	MD.	; Display the current register value HL
	call	readAddrInH	; 0d01  cd 0e 02	M..	; Read a new-value word in H
	pop	d		; 0d04  d1		Q	; Restore the current memory address in DE
	xchg			; 0d05  eb		k	; DE <-> HL, the new-value is now in DE, the current mem address is in HL
	mov	m,e		; 0d06  73		s	; Store the new-value word (in DE) in memory
	inx	h		; 0d07  23		#
	mov	m,d		; 0d08  72		r
	ret			; 0d09  c9		I
;
setRegisterByte:
	lxi	h,X1404		; 0d0a  21 04 14	!..	; Set H to before the start of the A ~ H memory region
	dad	b		; 0d0d  09		.	; HL := HL + BC. Add the offset for the matched register name
	call	printMemHexByte	; 0d0e  cd 42 02	MB.	; Display the current register value
	call	readLineTo1410	; 0d11  cd 7b 02	M{.	; Read a new-value string
	call	string1410ToByte; 0d14  cd 98 0e	M..	; Convert the new-value string to a byte in A
	mov	m,a		; 0d17  77		w	; Store the new-value byte in memory
	ret			; 0d18  c9		I
;
setFlags:
	call	printFlagsReg	; 0d19  cd 66 0d	Mf.	; Display the currently set flags
	call	readLineTo1410	; 0d1c  cd 7b 02	M{.	; Read a string to 1410h
	lxi	d,X1410		; 0d1f  11 10 14	...	; Set D to the start of the input string
	mvi	c,0		; 0d22  0e 00		..	; C := 0, will accumulate the new value for the F register
setSingleFlag:
	ldax	d		; 0d24  1a		.	; A := mem[D], the current char from the input string
	lxi	h,X0d80		; 0d25  21 80 0d	!..	; Position H to the base of the 'Flag Char' <-> 'BitMask' array
	mvi	b,5		; 0d28  06 05		..	; B := 5, the number of flag-chars to check
checkFlagName:
	cmp	m		; 0d2a  be		>	; Compare the current input char A with the current 'Flag Char' in mem[H]
	inx	h		; 0d2b  23		#	; Always move H to the next byte, which is the bitmask
	jz	setFlagBit	; 0d2c  ca 39 0d	J9.	; If equal, set the flag's bit (to 1)
	inx	h		; 0d2f  23		#	; Not equal. Move H to the next byte, the next 'Flag Char'
	dcr	b		; 0d30  05		.	; Decrement B, the number of remaining flag-chars to check
	jnz	checkFlagName	; 0d31  c2 2a 0d	B*.	; Loop back if B is non-zero
	mov	a,c		; 0d34  79		y	; The current input char A is not a 'Flag Char'. A := the new flags byte
	sta	X1404		; 0d35  32 04 14	2..	; mem[1404h] := A, store the new-value byte in memory
	ret			; 0d38  c9		I
;
setFlagBit:
	mov	a,c		; 0d39  79		y	; A := C, the current flags byte
	ora	m		; 0d3a  b6		6	; OR with the bit-mask at mem[H]
	mov	c,a		; 0d3b  4f		O	; Store the updated flags byte back into C
	inx	d		; 0d3c  13		.	; Move to and process the next byte of keyboard input
	jmp	setSingleFlag	; 0d3d  c3 24 0d	C$.
;
;
; Displays the values of the system registers, as stored in memory (at 1404h ~ 140Fh)
;
printRegisters:
	lxi	d,X0fdd		; 0d40  11 dd 0f	.].	; Print the register names' header
	call	printNLDString	; 0d43  cd fa 01	Mz.
	lxi	h,X1405		; 0d46  21 05 14	!..	; Set the current memory address at 1405h
	mvi	c,7		; 0d49  0e 07		..	; Iterate the seven single-byte registers: A, C, B, E, D, L and H
printRegH:
	mov	a,m		; 0d4b  7e		~	; Load the current memory byte in A and display it
	call	printHexByteSpace; 0d4c  cd 59 02	MY.
	inx	h		; 0d4f  23		#	; Advance to the next memory byte, decrement the loop counter
	dcr	c		; 0d50  0d		.
	jnz	printRegH	; 0d51  c2 4b 0d	BK.	; Jump back if there are more single-byte registers to print
	lhld	X140c		; 0d54  2a 0c 14	*..	; HL := mem[140C] - load and display the 16-bit value for SP
	call	printHexHL	; 0d57  cd 54 02	MT.
	lhld	X140e		; 0d5a  2a 0e 14	*..	; HL := mem[140E] - load and display the 16-bit value for PC
	call	printHexHL	; 0d5d  cd 54 02	MT.
	call	printFlagsReg	; 0d60  cd 66 0d	Mf.	; Display the status flags
	jmp	monitor		; 0d63  c3 74 01	Ct.
;
;
; Displays the F-registers flags, which are currently set (as stored in memory, at 1404h)
; These are the 'S', 'Z', 'A', 'P' and 'C' flags
;
printFlagsReg:
	lxi	h,X0d81		; 0d66  21 81 0d	!..	; Set the memory address to the start of the flags-to-bit array
	mvi	b,5		; 0d69  06 05		..	; Five flags to check
printFlag:
	lda	X1404		; 0d6b  3a 04 14	:..	; Load the whole status register in A
	ana	m		; 0d6e  a6		&	; AND with the bitmask for the current flag
	cnz	printFlagName	; 0d6f  c4 79 0d	Dy.	; Display the flag, if its bit was set
	inx	h		; 0d72  23		#	; Advance to the memory location for the next flag
	inx	h		; 0d73  23		#
	dcr	b		; 0d74  05		.
	jnz	printFlag	; 0d75  c2 6b 0d	Bk.	; Jump back, until all flags have been processed
	ret			; 0d78  c9		I
;
;
; Displays the name of the status flag, whose bit-mask is currently being pointed-at by H
; 
printFlagName:
	dcx	h		; 0d79  2b		+	; The flag name is in the previous byte
	mov	a,m		; 0d7a  7e		~	; Load the flag name into A and display it
	call	X00eb		; 0d7b  cd eb 00	Mk.
	inx	h		; 0d7e  23		#	; Restore H to its original value
	ret			; 0d7f  c9		I
;
;
; TODO
;
X0d80:	dw	8053h		; 0d80   53 80      S.
	dw	405ah		; 0d82   5a 40      Z@
	dw	1041h		; 0d84   41 10      A.
	dw	450h		; 0d86   50 04      P.
	dw	143h		; 0d88   43 01      C.
;
;
; Finds all ocurrencies of a byte sequence in a given memory range.
; The search sequence is entered as a comma-sequence of hex pairs, stored at 1410h.
; Then this sequence is converted to bytes, stored again at 1410h.
;
memFind:
	call	promptStartEnd	; 0d8a  cd 24 02	M$.	; Input start and end address, place them on the stack
	call	promptByte	; 0d8d  cd 75 02	Mu.	; Input a comma-separated list of bytes to search for. Stored at 1410h
	lxi	h,X1410		; 0d90  21 10 14	!..	; H := 1410h, the address of the keyboard input buffer
	mov	d,h		; 0d93  54		T	; D := 1410h
	mov	e,l		; 0d94  5d		]
	mvi	c,0		; 0d95  0e 00		..	; C := 00h - counter for the search byte-sequence length
commaListToBytes:
	call	stringDToByte	; 0d97  cd 9b 0e	M..	; Convert the current pair of hex chars to a byte in A
	mov	m,a		; 0d9a  77		w	; Store it at mem[H]
	inx	h		; 0d9b  23		#	; ++H - position it at the next byte of the search sequnce
	ldax	d		; 0d9c  1a		.	; A := mem[D], the latest char of the input string
	inx	d		; 0d9d  13		.	; ++D - move to the next char of the input string
	inr	c		; 0d9e  0c		.	; ++C - keep the sequence-length updated
	cpi	2ch		; 0d9f  fe 2c		~,	; Check A for ',' (2Ch) - the list separator
	jz	commaListToBytes; 0da1  ca 97 0d	J..	; Loop back, if there is another byte listed
	pop	h		; 0da4  e1		a	; H := &end
	xthl			; 0da5  e3		c	; H := &start. &end goes to the top of the stack
	call	reset1471	; 0da6  cd d7 0d	MW.	; Reset the output items counter
findAtH:
	lxi	d,X1410		; 0da9  11 10 14	...	; Set D to the start of the search-sequence
	mov	b,c		; 0dac  41		A	; B := number-of-bytes-to-search-for
matchDH:
	ldax	d		; 0dad  1a		.	; Load the next target byte into A
	cmp	m		; 0dae  be		>	; Compare with the current mem[H]
	jnz	findAtNextH	; 0daf  c2 c4 0d	BD.	; Abort the comparison, in case of a mismatch
	inx	h		; 0db2  23		#	; Increment both H (memory) and D (target)
	inx	d		; 0db3  13		.
	dcr	b		; 0db4  05		.	; Decrement B, number of remaining bytes to find
	jnz	matchDH		; 0db5  c2 ad 0d	B-.	; Loop back if there are more bytes to find
	mov	a,l		; 0db8  7d		}	; Match found. Adjust H to the start of the sequence
	sub	c		; 0db9  91		.	; HL := HL - 0C  (B is zero)
	mov	l,a		; 0dba  6f		o
	mov	a,h		; 0dbb  7c		|
	sbb	b		; 0dbc  98		.
	mov	h,a		; 0dbd  67		g
	call	printHexHL	; 0dbe  cd 54 02	MT.	; Display the match address
	call	dcr1471		; 0dc1  cd cf 0d	MO.	; Decrement the output items counter
findAtNextH:
	xchg			; 0dc4  eb		k	; DE <-> HL. D := current memory address
	xthl			; 0dc5  e3		c	; mem[SP] <-> HL. H := &end
	call	toMonitorIfDeqH	; 0dc6  cd 31 02	M1.	; "Return" if &current == &end
	xthl			; 0dc9  e3		c	; Restore the original values. H := current memory address
	xchg			; 0dca  eb		k
	inx	h		; 0dcb  23		#	; Advance to the next memory address
	jmp	findAtH		; 0dcc  c3 a9 0d	C).	; Test for a match at the new address
;
;
; Up to 12 five-byte 'XXXX ' addresses can be displayed on a single line.
; mem[1471h] contains the number of available slots, on the current display line.
; When this counter reaches zero, a new-line is displayed and the counter restarted
;
dcr1471:
	lda	X1471		; 0dcf  3a 71 14	:q.	; Decrement mem[1471h]. A := mem[1471h]
	dcr	a		; 0dd2  3d		=	; --A
	sta	X1471		; 0dd3  32 71 14	2q.	; mem[1471h] := A
	rnz			; 0dd6  c0		@	; Return if A is non-zero. Otherwise, reset to 0Ch
reset1471:
	mvi	a,0ch		; 0dd7  3e 0c		>.	; mem[1471h] := 0Ch
	sta	X1471		; 0dd9  32 71 14	2q.
	jmp	printNL		; 0ddc  c3 19 02	C..	; Print a new-line and return
;
;
; Copies a memory block from one location to another
; To avoid corruption, data is copied forward if &start > &to and backward if &start < &to
;
memCopy:
	call	promptStartEnd	; 0ddf  cd 24 02	M$.	; Read start & end addresses, put them on the stack
	lxi	d,X0e4d		; 0de2  11 4d 0e	.M.	; Prompt 'TO:' and read the destination address
	call	promptDReadH	; 0de5  cd 0b 02	M..	; H := &to
	pop	b		; 0de8  c1		A	; B := &end
	pop	d		; 0de9  d1		Q	; D := &start
	call	toMonitorIfDeqH	; 0dea  cd 31 02	M1.	; Compare &to and &start. Return if equal
	push	h		; 0ded  e5		e	; Swap B and H. H := &end, B := &to
	mov	h,b		; 0dee  60		`
	mov	l,c		; 0def  69		i
	pop	b		; 0df0  c1		A
	jnc	setBDestEnd	; 0df1  d2 fe 0d	R~.	; Copy memory backwards
memCopyForward:
	ldax	d		; 0df4  1a		.	; mem[B] := mem[D]
	stax	b		; 0df5  02		.
	call	toMonitorIfDeqH	; 0df6  cd 31 02	M1.	; Compare the 'current-from' D with &end H. Return if equal
	inx	d		; 0df9  13		.	; Increment both 'current-from' D and 'current-to' B
	inx	b		; 0dfa  03		.
	jmp	memCopyForward	; 0dfb  c3 f4 0d	Ct.
;
; Memory will be copied backwards. Change B from 'destination-start' to 'destination-end'
setBDestEnd:
	push	h		; 0dfe  e5		e	; Backup H
	mov	a,l		; 0dff  7d		}	; H := (H - D) = (&end - &start), the legth of the copied block
	sub	e		; 0e00  93		.
	mov	l,a		; 0e01  6f		o
	mov	a,h		; 0e02  7c		|
	sbb	d		; 0e03  9a		.
	mov	h,a		; 0e04  67		g
	dad	b		; 0e05  09		.	; H += B, i.e. H := &to + (&end - &start)
	push	h		; 0e06  e5		e	; B := H, i.e. B := &to + (&end - &start)
	pop	b		; 0e07  c1		A
	pop	h		; 0e08  e1		a	; Restore the original value of H
memCopyBackward:
	mov	a,m		; 0e09  7e		~	; mem[B] := mem[H]
	stax	b		; 0e0a  02		.
	call	toMonitorIfDeqH	; 0e0b  cd 31 02	M1.	; Compare the 'current-from' H with &start D. Return if equal
	dcx	b		; 0e0e  0b		.	; Decrement both 'current-from' H and 'current-to' B
	dcx	h		; 0e0f  2b		+
	jmp	memCopyBackward	; 0e10  c3 09 0e	C..
;
;
; Loads the values stored at 1404h ~ 140Fh (see memory map) to the system registers
;
memToRegisters:
	lxi	sp,X1404	; 0e13  31 04 14	1..	; Set the stack pointer to the base of the registers' memory storage
	pop	psw		; 0e16  f1		q	; Load the next two bytes into PSW:  PSW := PSW*, SP := 1406h
	pop	b		; 0e17  c1		A	; Load the next two bytes into B:  B := B*, SP := 1408h
	pop	d		; 0e18  d1		Q	; Load the next two bytes into D:  D := D*, SP := 140Ah
	pop	h		; 0e19  e1		a	; Load the next two bytes into H:  H := H*, SP := 140Ch
	pop	h		; 0e1a  e1		a	; Load the next two bytes into H:  H := SP*, SP := 140Eh
	sphl			; 0e1b  f9		y	; Copy H into SP:  H := SP*, SP := SP*
	lhld	X140e		; 0e1c  2a 0e 14	*..	; H := PC*, SP := SP*
	push	h		; 0e1f  e5		e	; Push H (PC*) on the stack, as a fake return address
	lhld	X140a		; 0e20  2a 0a 14	*..	; H := H*
	ret			; 0e23  c9		I	; "Return" to the last address on the stack, i.e. PC := PC*
;
;
; Stores the system registers in memory, at addresses 1404h ~ 140Fh (see memory map)
; The values stored (PC and SP, in particular) are the ones *before* the call to RST2
; 
registersToMem:
	shld	X140a		; 0e24  22 0a 14	"..	; H* := H
	pop	h		; 0e27  e1		a	; H := PC-before-last-call (it was on the top of the stack)
	shld	X140e		; 0e28  22 0e 14	"..	; PC* := PC-before-last-call
	push	psw		; 0e2b  f5		u	; Backup (A, F)
	lxi	h,X0002		; 0e2c  21 02 00	!..	; H := SP + 2 = SP-before-last-call
	dad	sp		; 0e2f  39		9
	shld	X140c		; 0e30  22 0c 14	"..	; SP* := SP-before-last-call
	pop	psw		; 0e33  f1		q	; Restore (A, F)
	lxi	sp,X140a	; 0e34  31 0a 14	1..	; Set the stack base at 140Ah. Pushes will overwrite D*, B* and PSW*
	push	d		; 0e37  d5		U	; D* := D
	push	b		; 0e38  c5		E	; B* := B
	push	psw		; 0e39  f5		u	; PSW* := PSW
	lxi	sp,X1470	; 0e3a  31 70 14	1p.	; Set the stack base at 1470h (the default address)
	jmp	printRegisters	; 0e3d  c3 40 0d	C@.	; TODO: Print the registers?
;
X0e40:	db	'MORE? '				; 0e40
	db	4					; 0e46 .
X0e47:	db	0dh,0ah					; 0e47 ..
	db	'END'					; 0e49
	db	4					; 0e4c .
X0e4d:	db	'TO:'					; 0e4d
	db	4					; 0e50 .
;
; Converts the '0'~'9', 'A'~'F' character in A to a 00h~0Fh value.
; The CARRY flag is set in case of an error.
;
;
hexCharToValue:
	sui	30h		; 0e51  d6 30		V0	; '0' (30h) -> 00h
	rc			; 0e53  d8		X	; If A originally had an ASCII below '0', return with the error flag set
	cpi	0ah		; 0e54  fe 0a		~.	; Compare A with 10 (0Ah), i.e. originally ':'
	cmc			; 0e56  3f		?	; If less-than, i.e. A was '0'~'9', invert the carry flag to indicate success and return
	rnc			; 0e57  d0		P
	cpi	11h		; 0e58  fe 11		~.	; Compare A with 17 (11h), i.e. originally 'A'
	rc			; 0e5a  d8		X	; If less-than, return with an error
	cpi	17h		; 0e5b  fe 17		~.	; Compare A with 23 (17h), i.e. originally 'G'
	cmc			; 0e5d  3f		?	; If greater-or-equal, invert the carry flag to indicate an error and return
	rc			; 0e5e  d8		X
	sui	7		; 0e5f  d6 07		V.	; The value in A is 17 ~ 22. Subtract 7 (07h) to bring it to 10 ~ 15 (0Ah ~ 0Fh)
	ret			; 0e61  c9		I
;
;
; Waits for "Data Available" (DAV) and reads the UART data byte to A (IO address 0x04)
;
readFromUART:
	in	1		; 0e62  db 01		[.	; Read UART status byte
	ani	1		; 0e64  e6 01		f.	; Check for DAV flag
	jz	readFromUART	; 0e66  ca 62 0e	Jb.	; Jump back if DAV flag is not set
	in	4		; 0e69  db 04		[.	; Read UART data byte
	ret			; 0e6b  c9		I
;
;
; Displays a 'TAPE HEADER:' prompt and reads input to the 1410h memory buffer
;
promptTapeHeader:
	call	write00hToIO7	; 0e6c  cd 4a 00	MJ.
	lxi	d,X0fd0		; 0e6f  11 d0 0f	.P.	; Display the 'TAPE HEADER:' prompt
	call	printNLDString	; 0e72  cd fa 01	Mz.
	call	readLineTo1410	; 0e75  cd 7b 02	M{.	; Read the keyboard input
	jmp	write80hToIO7	; 0e78  c3 f6 03	Cv.	; Also returns
;
;
; Display 'READ ERROR' and fall-through to the Monitor
;
monitorReadError:
	lxi	d,X037a		; 0e7b  11 7a 03	.z.	; Set D to the address of the 'READ' string
monitorDError:
	call	printNLDString	; 0e7e  cd fa 01	Mz.	; Print a new-line and the string in D
	jmp	monitorError	; 0e81  c3 5e 01	C^.	; Display ' ERROR' and go to monitor
;
X0e84:	mov	a,b		; 0e84  78		x
	mov	m,a		; 0e85  77		w
	ana	a		; 0e86  a7		'
	rp			; 0e87  f0		p
	pop	h		; 0e88  e1		a
	ei			; 0e89  fb		{
	mvi	b,7fh		; 0e8a  06 7f		..
	ana	b		; 0e8c  a0		 
	mov	c,a		; 0e8d  4f		O
	cmp	b		; 0e8e  b8		8
	mvi	a,8		; 0e8f  3e 08		>.
	rz			; 0e91  c8		H
	mov	a,c		; 0e92  79		y
	cpi	5fh		; 0e93  fe 5f		~_
	rnz			; 0e95  c0		@
	mov	a,b		; 0e96  78		x
	ret			; 0e97  c9		I
;
;
; Converts a line of input at 1410h to a byte value stored in A
;
string1410ToByte:
	lxi	d,X1410		; 0e98  11 10 14	...	; Set the address of the keyboard buffer in D
stringDToByte:
	push	h		; 0e9b  e5		e	; Backup H and B
	push	b		; 0e9c  c5		E
	call	stringDToAddr	; 0e9d  cd 9b 03	M..	; Perform the conversion
	pop	b		; 0ea0  c1		A	; Restore H and B. The 16-bit conversion result (in H) are discarded
	pop	h		; 0ea1  e1		a	; and only the LSB byte remains in A
	ret			; 0ea2  c9		I
;
;
; Prompts for input of an address and jumps there
;
jumpToAddress:
	call	promptStartReadH; 0ea3  cd 08 02	M..	; Get the address
	pchl			; 0ea6  e9		i	; PC := HL, jump to the address
;
;
; Prints a hex dump of a memory region. 
; Each line starts with a memory address, followed by (up to) 16 bytes of memory data
;
memDump:
	call	promptStartEnd	; 0ea7  cd 24 02	M$.	; Read start & end addresses, put them on the stack
	pop	d		; 0eaa  d1		Q	; D := &end
	pop	h		; 0eab  e1		a	; H := &start
memDumpAddress:
	call	printNLHexWord	; 0eac  cd c4 03	MD.	; Print a new-line and the current memory address
memDumpByte:
	call	printMemHexByte	; 0eaf  cd 42 02	MB.	; Print the current memory byte
	call	toMonitorIfDeqH	; 0eb2  cd 31 02	M1.	; If D == H, jump to monitor
	inx	h		; 0eb5  23		#	; Advance to the next memory address
	mov	a,l		; 0eb6  7d		}	; Check if the new address ends in a zero nibble
	ani	0fh		; 0eb7  e6 0f		f.
	jnz	memDumpByte	; 0eb9  c2 af 0e	B/.	; If not, continue with the byte-dumps
	jmp	memDumpAddress	; 0ebc  c3 ac 0e	C,.	; If yes, start a new line of print
;
	org	0ec0h
;
X0ec0:	db	'PROGRAM'				; 0ec0
	db	4					; 0ec7 .
X0ec8:	db	'HLDEBCA'				; 0ec8
X0ecf:	db	'START:'				; 0ecf
	db	4					; 0ed5 .
X0ed6:	db	' ERROR'				; 0ed6
	db	4					; 0edc .
X0edd:	db	'FUNCTION? ENTER MONITOR OPTION'	; 0edd
	db	4					; 0efb .
;
	db	20h		; 0efc  20		 
	db	20h		; 0efd  20		 
	db	20h		; 0efe  20		 
	db	20h		; 0eff  20		 
	db	20h		; 0f00  20		 
	nop			; 0f01  00		.
;
X0f02:	db	'FILES FOUND:'				; 0f02
	db	4					; 0f0e .
;
; Inverts the byte at memory address 1472
;
;
invert1472:
	lxi	h,X1472		; 0f0f  21 72 14	!r.	; Set address to 1472
	jmp	invertMemByte	; 0f12  c3 18 0f	C..
;
;
; Inverts the byte at memory address 1401
;
invert1401:
	lxi	h,X1401		; 0f15  21 01 14	!..	; Set address to 1401
;
; Inverts (performs a bitwise NOT) the byte at the current memory address
;
invertMemByte:
	mov	a,m		; 0f18  7e		~	; Load memory byte into A
	cma			; 0f19  2f		/	; Invert A
	mov	m,a		; 0f1a  77		w	; Write back to memory
	ret			; 0f1b  c9		I
;
X0f1c:	call	promptStartReadH; 0f1c  cd 08 02	M..
	mvi	c,64h		; 0f1f  0e 64		.d
	lxi	d,X0400		; 0f21  11 00 04	...
X0f24:	push	h		; 0f24  e5		e
	push	d		; 0f25  d5		U
	lxi	d,RST0		; 0f26  11 00 00	...
X0f29:	call	X0f5f		; 0f29  cd 5f 0f	M_.
	mov	b,a		; 0f2c  47		G
	ora	m		; 0f2d  b6		6
	cmp	b		; 0f2e  b8		8
	jnz	monitorProgError; 0f2f  c2 72 0f	Br.
	mvi	a,88h		; 0f32  3e 88		>.
	mvi	b,8		; 0f34  06 08		..
	call	X0f63		; 0f36  cd 63 0f	Mc.
X0f39:	in	0feh		; 0f39  db fe		[~
	ana	a		; 0f3b  a7		'
	jm	X0f39		; 0f3c  fa 39 0f	z9.
	mov	a,c		; 0f3f  79		y
	cpi	1		; 0f40  fe 01		~.
	jnz	X0f4c		; 0f42  c2 4c 0f	BL.
	call	X0f5f		; 0f45  cd 5f 0f	M_.
	cmp	m		; 0f48  be		>
	jnz	monitorReadError; 0f49  c2 7b 0e	B{.
X0f4c:	inx	h		; 0f4c  23		#
	inx	d		; 0f4d  13		.
	xthl			; 0f4e  e3		c
	call	cmpDH		; 0f4f  cd bf 00	M?.
	xthl			; 0f52  e3		c
	jnz	X0f29		; 0f53  c2 29 0f	B).
	pop	d		; 0f56  d1		Q
	pop	h		; 0f57  e1		a
	dcr	c		; 0f58  0d		.
	jnz	X0f24		; 0f59  c2 24 0f	B$.
	jmp	monitorEnd	; 0f5c  c3 3d 03	C=.
;
X0f5f:	mvi	a,98h		; 0f5f  3e 98		>.
	mvi	b,4		; 0f61  06 04		..
X0f63:	out	0ffh		; 0f63  d3 ff		S.
	mov	a,e		; 0f65  7b		{
	out	0fdh		; 0f66  d3 fd		S}
	mov	a,m		; 0f68  7e		~
	out	0fch		; 0f69  d3 fc		S|
	mov	a,d		; 0f6b  7a		z
	ora	b		; 0f6c  b0		0
	out	0feh		; 0f6d  d3 fe		S~
	in	0fch		; 0f6f  db fc		[|
	ret			; 0f71  c9		I
;
;
; Display 'PROGRAM ERROR' and fall-through to the Monitor
;
monitorProgError:
	lxi	d,X0ec0		; 0f72  11 c0 0e	.@.	; Set D to the address of the 'PROGRAM' string
	jmp	monitorDError	; 0f75  c3 7e 0e	C~.	; Print a new-line, the string in D, ' ERROR' and go to monitor
;
;
; Infinite loop of reading a char from the keyboard and then displaying it
;
readLoopKBD:
	call	X00e8		; 0f78  cd e8 00	Mh.
	jmp	readLoopKBD	; 0f7b  c3 78 0f	Cx.
;
;
; Jump table with 26 Monitor functions, 'A' to 'Z'
;
X0f7e:	dw	writeStrToMem		; 0f7e   46 02      F.
	dw	X0400		; 0f80   00 04      ..
	dw	memToRegisters		; 0f82   13 0e      ..
	dw	printMemString		; 0f84   f6 01      v.
	dw	memSet		; 0f86   7f 03      ..
	dw	memFind		; 0f88   8a 0d      ..
	dw	jumpToAddress		; 0f8a   a3 0e      #.
	dw	memDump		; 0f8c   a7 0e      '.
	dw	readProgFrmUART		; 0f8e   43 03      C.
	dw	Xf7cc		; 0f90   cc f7      Lw
	dw	invert1472		; 0f92   0f 0f      ..
	dw	memList		; 0f94   ca 03      J.
	dw	toggleIO7		; 0f96   ef 03      o.
	dw	X1473		; 0f98   73 14      s.
	dw	writeProgToUART		; 0f9a   22 03      ".
	dw	memEdit		; 0f9c   a2 0c      ".
	dw	X1473		; 0f9e   73 14      s.
	dw	setMemRegisters		; 0fa0   ca 0c      J.
	dw	memCopy		; 0fa2   df 0d      _.
	dw	Xc000		; 0fa4   00 c0      .@
	dw	X1473		; 0fa6   73 14      s.
	dw	invert1401		; 0fa8   15 0f      ..
	dw	readLoopKBD		; 0faa   78 0f      x.
	dw	Xe22d		; 0fac   2d e2      -b
	dw	X1473		; 0fae   73 14      s.
	dw	X0f1c		; 0fb0   1c 0f      ..
;
X0fb2:	db	'BYTE:'					; 0fb2
	db	4					; 0fb7 .
X0fb8:	db	'ITKROM V1.2'				; 0fb8
	db	0dh,0ah					; 0fc3 ..
X0fc5:	db	'END:'					; 0fc5
	db	4					; 0fc9 .
	db	'PORT:'					; 0fca
	db	4					; 0fcf .
X0fd0:	db	'TAPE HEADER:'				; 0fd0
	db	4					; 0fdc .
X0fdd:	db	'A  C  B  E  D  L  H  SP   PC'		; 0fdd
X0ff9:	db	0dh,0ah,4				; 0ff9 ...
;
;	Miscellaneous equates
;
;  These are addresses referenced in the code but
;  which are in the middle of a multibyte instruction
;  or are addresses outside the initialized space
;
X0002	equ	2
X0007	equ	7
X02f1	equ	2f1h
X1400	equ	1400h
X1401	equ	1401h
X1402	equ	1402h
X1404	equ	1404h
X1405	equ	1405h
X140a	equ	140ah
X140c	equ	140ch
X140e	equ	140eh
X1410	equ	1410h
X1430	equ	1430h
X1433	equ	1433h
X1436	equ	1436h
X1439	equ	1439h
X143c	equ	143ch
X1470	equ	1470h
X1471	equ	1471h
X1472	equ	1472h
X1473	equ	1473h
X1476	equ	1476h
X1477	equ	1477h
X1479	equ	1479h
X147a	equ	147ah
X1481	equ	1481h
X14ff	equ	14ffh
X1600	equ	1600h
X8032	equ	8032h
Xc000	equ	0c000h
Xe22d	equ	0e22dh
Xf7cc	equ	0f7cch
;
	end
;

